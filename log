Redis database connected
{ s: 
   { pkFactory: 
      { [Function: ObjectID]
        index: 15757181,
        createPk: [Function: createPk],
        createFromTime: [Function: createFromTime],
        createFromHexString: [Function: createFromHexString],
        isValid: [Function: isValid],
        ObjectID: [Circular],
        ObjectId: [Circular],
        createPkAsync: [Function],
        createFromTimeAsync: [Function],
        createFromHexStringAsync: [Function],
        isValidAsync: [Function],
        ObjectIDAsync: [Function],
        ObjectIdAsync: [Function] },
     db: 
      EventEmitter {
        domain: null,
        _events: {},
        _eventsCount: 0,
        _maxListeners: undefined,
        s: 
         { databaseName: 'admin',
           dbCache: {},
           children: [],
           topology: 
            EventEmitter {
              domain: null,
              _events: 
               { error: [Function],
                 timeout: [Function],
                 close: [Function],
                 parseError: [Function],
                 fullsetup: { [Function: g] listener: [Function] },
                 all: { [Function: g] listener: [Function] },
                 reconnect: [Function] },
              _eventsCount: 7,
              _maxListeners: undefined,
              clientInfo: 
               { driver: { name: 'nodejs', version: '2.2.25' },
                 os: 
                  { type: 'Linux',
                    name: 'linux',
                    architecture: 'x64',
                    version: '3.16.0-4-amd64' },
                 platform: 'Node.js v4.7.2, LE' },
              s: 
               { server: 
                  EventEmitter {
                    domain: null,
                    _events: 
                     { reconnect: [Function],
                       reconnectFailed: [Function],
                       timeout: [Function],
                       error: { [Function: g] listener: [Function] },
                       close: [Function],
                       destroy: [Function],
                       serverDescriptionChanged: [Function],
                       serverHeartbeatStarted: [Function],
                       serverHeartbeatSucceeded: [Function],
                       serverHeartbeatFailed: [Function],
                       serverOpening: [Function],
                       serverClosed: [Function],
                       topologyOpening: [Function],
                       topologyClosed: [Function],
                       topologyDescriptionChanged: [Function],
                       attemptReconnect: [Function],
                       monitoring: [Function] },
                    _eventsCount: 17,
                    _maxListeners: undefined,
                    id: 0,
                    s: 
                     { options: 
                        { host: '127.0.0.1',
                          port: 27017,
                          disconnectHandler: 
                           { s: 
                              { storedOps: [],
                                storeOptions: { force: false, bufferMaxEntries: -1 },
                                topology: [Circular] },
                             length: [Getter] },
                          cursorFactory: 
                           { [Function]
                             super_: 
                              { [Function: Readable]
                                ReadableState: [Function: ReadableState],
                                super_: 
                                 { [Function: Stream]
                                   super_: 
                                    { [Function: EventEmitter]
                                      EventEmitter: [Circular],
                                      usingDomains: false,
                                      defaultMaxListeners: 10,
                                      init: [Function],
                                      listenerCount: [Function] },
                                   Readable: [Circular],
                                   Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                                   Duplex: { [Function: Duplex] super_: [Circular] },
                                   Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                                   PassThrough: 
                                    { [Function: PassThrough]
                                      super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                                   Stream: [Circular] },
                                _fromList: [Function: fromList] },
                             define: 
                              { name: 'Cursor',
                                object: [Circular],
                                stream: true,
                                instrumentations: 
                                 { 'callback=true,promise=true': 
                                    { methods: 
                                       [ 'hasNext',
                                         'next',
                                         'nextObject',
                                         'next',
                                         'toArray',
                                         'count',
                                         'close',
                                         'explain' ],
                                      options: { callback: true, promise: true } },
                                   'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                                    { methods: 
                                       [ 'filter',
                                         'maxScan',
                                         'hint',
                                         'min',
                                         'max',
                                         'returnKey',
                                         'showRecordId',
                                         'snapshot',
                                         'setCursorOption',
                                         'addCursorFlag',
                                         'addQueryModifier',
                                         'comment',
                                         'maxAwaitTimeMS',
                                         'maxTimeMS',
                                         'maxTimeMs',
                                         'project',
                                         'sort',
                                         'batchSize',
                                         'collation',
                                         'limit',
                                         'skip',
                                         'setReadPreference',
                                         'map',
                                         'stream' ],
                                      options: { callback: false, promise: false, returns: [ [Circular] ] } },
                                   'callback=true,promise=false': 
                                    { methods: [ 'each', 'forEach' ],
                                      options: { callback: true, promise: false } },
                                   'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                                    { methods: [ 'isClosed' ],
                                      options: 
                                       { callback: false,
                                         promise: false,
                                         returns: [ [Function: Boolean] ] } },
                                   'callback=false,promise=false': 
                                    { methods: [ 'destroy' ],
                                      options: { callback: false, promise: false } } } },
                             INIT: 0,
                             OPEN: 1,
                             CLOSED: 2,
                             GET_MORE: 3,
                             super_Async: [Function] },
                          reconnect: true,
                          emitError: true,
                          size: 5,
                          socketOptions: {},
                          socketTimeout: 30000,
                          connectionTimeout: 30000,
                          clientInfo: 
                           { driver: { name: 'nodejs', version: '2.2.25' },
                             os: 
                              { type: 'Linux',
                                name: 'linux',
                                architecture: 'x64',
                                version: '3.16.0-4-amd64' },
                             platform: 'Node.js v4.7.2, LE' },
                          readPreference: 
                           { _type: 'ReadPreference',
                             mode: 'primary',
                             tags: undefined,
                             options: undefined },
                          promiseLibrary: [Function: Promise],
                          bson: {} },
                       logger: { className: 'Server' },
                       Cursor: 
                        { [Function]
                          super_: 
                           { [Function: Readable]
                             ReadableState: [Function: ReadableState],
                             super_: 
                              { [Function: Stream]
                                super_: 
                                 { [Function: EventEmitter]
                                   EventEmitter: [Circular],
                                   usingDomains: false,
                                   defaultMaxListeners: 10,
                                   init: [Function],
                                   listenerCount: [Function] },
                                Readable: [Circular],
                                Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                                Duplex: { [Function: Duplex] super_: [Circular] },
                                Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                                PassThrough: 
                                 { [Function: PassThrough]
                                   super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                                Stream: [Circular] },
                             _fromList: [Function: fromList] },
                          define: 
                           { name: 'Cursor',
                             object: [Circular],
                             stream: true,
                             instrumentations: 
                              { 'callback=true,promise=true': 
                                 { methods: 
                                    [ 'hasNext',
                                      'next',
                                      'nextObject',
                                      'next',
                                      'toArray',
                                      'count',
                                      'close',
                                      'explain' ],
                                   options: { callback: true, promise: true } },
                                'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                                 { methods: 
                                    [ 'filter',
                                      'maxScan',
                                      'hint',
                                      'min',
                                      'max',
                                      'returnKey',
                                      'showRecordId',
                                      'snapshot',
                                      'setCursorOption',
                                      'addCursorFlag',
                                      'addQueryModifier',
                                      'comment',
                                      'maxAwaitTimeMS',
                                      'maxTimeMS',
                                      'maxTimeMs',
                                      'project',
                                      'sort',
                                      'batchSize',
                                      'collation',
                                      'limit',
                                      'skip',
                                      'setReadPreference',
                                      'map',
                                      'stream' ],
                                   options: { callback: false, promise: false, returns: [ [Circular] ] } },
                                'callback=true,promise=false': 
                                 { methods: [ 'each', 'forEach' ],
                                   options: { callback: true, promise: false } },
                                'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                                 { methods: [ 'isClosed' ],
                                   options: 
                                    { callback: false,
                                      promise: false,
                                      returns: [ [Function: Boolean] ] } },
                                'callback=false,promise=false': 
                                 { methods: [ 'destroy' ],
                                   options: { callback: false, promise: false } } } },
                          INIT: 0,
                          OPEN: 1,
                          CLOSED: 2,
                          GET_MORE: 3,
                          super_Async: [Function] },
                       bson: {},
                       pool: 
                        EventEmitter {
                          domain: null,
                          _events: 
                           { close: [Function],
                             error: [Function],
                             timeout: [Function],
                             parseError: [Function],
                             connect: [Function],
                             reconnect: [Function],
                             reconnectFailed: [Function] },
                          _eventsCount: 7,
                          _maxListeners: undefined,
                          options: 
                           { host: '127.0.0.1',
                             port: 27017,
                             size: 5,
                             connectionTimeout: 30000,
                             socketTimeout: 30000,
                             keepAlive: true,
                             keepAliveInitialDelay: 0,
                             noDelay: true,
                             ssl: false,
                             checkServerIdentity: true,
                             ca: null,
                             crl: null,
                             cert: null,
                             key: null,
                             passPhrase: null,
                             rejectUnauthorized: false,
                             promoteLongs: true,
                             promoteValues: true,
                             promoteBuffers: false,
                             reconnect: true,
                             reconnectInterval: 1000,
                             reconnectTries: 30,
                             domainsEnabled: false,
                             disconnectHandler: 
                              { s: 
                                 { storedOps: [],
                                   storeOptions: { force: false, bufferMaxEntries: -1 },
                                   topology: [Circular] },
                                length: [Getter] },
                             cursorFactory: 
                              { [Function]
                                super_: 
                                 { [Function: Readable]
                                   ReadableState: [Function: ReadableState],
                                   super_: 
                                    { [Function: Stream]
                                      super_: 
                                       { [Function: EventEmitter]
                                         EventEmitter: [Circular],
                                         usingDomains: false,
                                         defaultMaxListeners: 10,
                                         init: [Function],
                                         listenerCount: [Function] },
                                      Readable: [Circular],
                                      Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                                      Duplex: { [Function: Duplex] super_: [Circular] },
                                      Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                                      PassThrough: 
                                       { [Function: PassThrough]
                                         super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                                      Stream: [Circular] },
                                   _fromList: [Function: fromList] },
                                define: 
                                 { name: 'Cursor',
                                   object: [Circular],
                                   stream: true,
                                   instrumentations: 
                                    { 'callback=true,promise=true': 
                                       { methods: 
                                          [ 'hasNext',
                                            'next',
                                            'nextObject',
                                            'next',
                                            'toArray',
                                            'count',
                                            'close',
                                            'explain' ],
                                         options: { callback: true, promise: true } },
                                      'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                                       { methods: 
                                          [ 'filter',
                                            'maxScan',
                                            'hint',
                                            'min',
                                            'max',
                                            'returnKey',
                                            'showRecordId',
                                            'snapshot',
                                            'setCursorOption',
                                            'addCursorFlag',
                                            'addQueryModifier',
                                            'comment',
                                            'maxAwaitTimeMS',
                                            'maxTimeMS',
                                            'maxTimeMs',
                                            'project',
                                            'sort',
                                            'batchSize',
                                            'collation',
                                            'limit',
                                            'skip',
                                            'setReadPreference',
                                            'map',
                                            'stream' ],
                                         options: { callback: false, promise: false, returns: [ [Circular] ] } },
                                      'callback=true,promise=false': 
                                       { methods: [ 'each', 'forEach' ],
                                         options: { callback: true, promise: false } },
                                      'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                                       { methods: [ 'isClosed' ],
                                         options: 
                                          { callback: false,
                                            promise: false,
                                            returns: [ [Function: Boolean] ] } },
                                      'callback=false,promise=false': 
                                       { methods: [ 'destroy' ],
                                         options: { callback: false, promise: false } } } },
                                INIT: 0,
                                OPEN: 1,
                                CLOSED: 2,
                                GET_MORE: 3,
                                super_Async: [Function] },
                             emitError: true,
                             socketOptions: {},
                             clientInfo: 
                              { driver: { name: 'nodejs', version: '2.2.25' },
                                os: 
                                 { type: 'Linux',
                                   name: 'linux',
                                   architecture: 'x64',
                                   version: '3.16.0-4-amd64' },
                                platform: 'Node.js v4.7.2, LE' },
                             readPreference: 
                              { _type: 'ReadPreference',
                                mode: 'primary',
                                tags: undefined,
                                options: undefined },
                             promiseLibrary: [Function: Promise],
                             bson: {} },
                          id: 0,
                          retriesLeft: 30,
                          reconnectId: null,
                          logger: { className: 'Pool' },
                          state: 'connected',
                          availableConnections: 
                           [ EventEmitter {
                               domain: null,
                               _events: 
                                { error: { [Function: g] listener: [Function] },
                                  close: { [Function: g] listener: [Function] },
                                  timeout: { [Function: g] listener: [Function] },
                                  parseError: { [Function: g] listener: [Function] } },
                               _eventsCount: 4,
                               _maxListeners: undefined,
                               options: 
                                { host: '127.0.0.1',
                                  port: 27017,
                                  size: 5,
                                  connectionTimeout: 30000,
                                  socketTimeout: 30000,
                                  keepAlive: true,
                                  keepAliveInitialDelay: 0,
                                  noDelay: true,
                                  ssl: false,
                                  checkServerIdentity: true,
                                  ca: null,
                                  crl: null,
                                  cert: null,
                                  key: null,
                                  passPhrase: null,
                                  rejectUnauthorized: false,
                                  promoteLongs: true,
                                  promoteValues: true,
                                  promoteBuffers: false,
                                  reconnect: true,
                                  reconnectInterval: 1000,
                                  reconnectTries: 30,
                                  domainsEnabled: false,
                                  disconnectHandler: 
                                   { s: 
                                      { storedOps: [],
                                        storeOptions: { force: false, bufferMaxEntries: -1 },
                                        topology: [Circular] },
                                     length: [Getter] },
                                  cursorFactory: 
                                   { [Function]
                                     super_: 
                                      { [Function: Readable]
                                        ReadableState: [Function: ReadableState],
                                        super_: 
                                         { [Function: Stream]
                                           super_: 
                                            { [Function: EventEmitter]
                                              EventEmitter: [Circular],
                                              usingDomains: false,
                                              defaultMaxListeners: 10,
                                              init: [Function],
                                              listenerCount: [Function] },
                                           Readable: [Circular],
                                           Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                                           Duplex: { [Function: Duplex] super_: [Circular] },
                                           Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                                           PassThrough: 
                                            { [Function: PassThrough]
                                              super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                                           Stream: [Circular] },
                                        _fromList: [Function: fromList] },
                                     define: 
                                      { name: 'Cursor',
                                        object: [Circular],
                                        stream: true,
                                        instrumentations: 
                                         { 'callback=true,promise=true': 
                                            { methods: 
                                               [ 'hasNext',
                                                 'next',
                                                 'nextObject',
                                                 'next',
                                                 'toArray',
                                                 'count',
                                                 'close',
                                                 'explain' ],
                                              options: { callback: true, promise: true } },
                                           'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                                            { methods: 
                                               [ 'filter',
                                                 'maxScan',
                                                 'hint',
                                                 'min',
                                                 'max',
                                                 'returnKey',
                                                 'showRecordId',
                                                 'snapshot',
                                                 'setCursorOption',
                                                 'addCursorFlag',
                                                 'addQueryModifier',
                                                 'comment',
                                                 'maxAwaitTimeMS',
                                                 'maxTimeMS',
                                                 'maxTimeMs',
                                                 'project',
                                                 'sort',
                                                 'batchSize',
                                                 'collation',
                                                 'limit',
                                                 'skip',
                                                 'setReadPreference',
                                                 'map',
                                                 'stream' ],
                                              options: { callback: false, promise: false, returns: [ [Circular] ] } },
                                           'callback=true,promise=false': 
                                            { methods: [ 'each', 'forEach' ],
                                              options: { callback: true, promise: false } },
                                           'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                                            { methods: [ 'isClosed' ],
                                              options: 
                                               { callback: false,
                                                 promise: false,
                                                 returns: [ [Function: Boolean] ] } },
                                           'callback=false,promise=false': 
                                            { methods: [ 'destroy' ],
                                              options: { callback: false, promise: false } } } },
                                     INIT: 0,
                                     OPEN: 1,
                                     CLOSED: 2,
                                     GET_MORE: 3,
                                     super_Async: [Function] },
                                  emitError: true,
                                  socketOptions: {},
                                  clientInfo: 
                                   { driver: { name: 'nodejs', version: '2.2.25' },
                                     os: 
                                      { type: 'Linux',
                                        name: 'linux',
                                        architecture: 'x64',
                                        version: '3.16.0-4-amd64' },
                                     platform: 'Node.js v4.7.2, LE' },
                                  readPreference: 
                                   { _type: 'ReadPreference',
                                     mode: 'primary',
                                     tags: undefined,
                                     options: undefined },
                                  promiseLibrary: [Function: Promise],
                                  bson: {} },
                               id: 0,
                               logger: { className: 'Connection' },
                               bson: {},
                               tag: undefined,
                               messageHandler: [Function],
                               maxBsonMessageSize: 67108864,
                               port: 27017,
                               host: '127.0.0.1',
                               keepAlive: true,
                               keepAliveInitialDelay: 0,
                               noDelay: true,
                               connectionTimeout: 30000,
                               socketTimeout: 30000,
                               destroyed: false,
                               domainSocket: false,
                               singleBufferSerializtion: true,
                               serializationFunction: 'toBinUnified',
                               ca: null,
                               crl: null,
                               cert: null,
                               key: null,
                               passphrase: null,
                               ssl: false,
                               rejectUnauthorized: false,
                               checkServerIdentity: true,
                               responseOptions: 
                                { promoteLongs: true,
                                  promoteValues: true,
                                  promoteBuffers: false },
                               flushing: false,
                               queue: [],
                               connection: 
                                Socket {
                                  _connecting: false,
                                  _hadError: false,
                                  _handle: 
                                   TCP {
                                     bytesRead: 194,
                                     _externalStream: {},
                                     fd: 12,
                                     reading: true,
                                     owner: [Circular],
                                     onread: [Function: onread],
                                     onconnection: null,
                                     writeQueueSize: 0 },
                                  _parent: null,
                                  _host: null,
                                  _readableState: 
                                   ReadableState {
                                     objectMode: false,
                                     highWaterMark: 16384,
                                     buffer: [],
                                     length: 0,
                                     pipes: null,
                                     pipesCount: 0,
                                     flowing: true,
                                     ended: false,
                                     endEmitted: false,
                                     reading: true,
                                     sync: false,
                                     needReadable: true,
                                     emittedReadable: false,
                                     readableListening: false,
                                     resumeScheduled: false,
                                     defaultEncoding: 'utf8',
                                     ranOut: false,
                                     awaitDrain: 0,
                                     readingMore: false,
                                     decoder: null,
                                     encoding: null },
                                  readable: true,
                                  domain: null,
                                  _events: 
                                   { end: { [Function: g] listener: [Function: onend] },
                                     finish: [Function: onSocketFinish],
                                     _socketEnd: [Function: onSocketEnd],
                                     connect: [ [Function] ],
                                     error: { [Function: g] listener: [Function] },
                                     timeout: { [Function: g] listener: [Function] },
                                     close: { [Function: g] listener: [Function] },
                                     data: [Function] },
                                  _eventsCount: 8,
                                  _maxListeners: undefined,
                                  _writableState: 
                                   WritableState {
                                     objectMode: false,
                                     highWaterMark: 16384,
                                     needDrain: false,
                                     ending: false,
                                     ended: false,
                                     finished: false,
                                     decodeStrings: false,
                                     defaultEncoding: 'utf8',
                                     length: 0,
                                     writing: false,
                                     corked: 0,
                                     sync: false,
                                     bufferProcessing: false,
                                     onwrite: [Function],
                                     writecb: null,
                                     writelen: 0,
                                     bufferedRequest: null,
                                     lastBufferedRequest: null,
                                     pendingcb: 0,
                                     prefinished: false,
                                     errorEmitted: false,
                                     bufferedRequestCount: 0,
                                     corkedRequestsFree: CorkedRequest { next: null, entry: null, finish: [Function] } },
                                  writable: true,
                                  allowHalfOpen: false,
                                  destroyed: false,
                                  _bytesDispatched: 263,
                                  _sockname: null,
                                  _pendingData: null,
                                  _pendingEncoding: '',
                                  server: null,
                                  _server: null,
                                  _idleTimeout: 30000,
                                  _idleNext: { _idleNext: [Circular], _idlePrev: [Circular] },
                                  _idlePrev: { _idleNext: [Circular], _idlePrev: [Circular] },
                                  _idleStart: 684,
                                  read: [Function],
                                  _consuming: true },
                               writeStream: null,
                               hashedName: '1af0a80ead1d9e3c1a02ad090ffe77ff1334aae9',
                               workItems: [],
                               buffer: null,
                               sizeOfMessage: 0,
                               bytesRead: 0,
                               stubBuffer: null } ],
                          inUseConnections: [],
                          connectingConnections: [],
                          executing: false,
                          queue: [],
                          authProviders: 
                           { mongocr: { bson: {}, authStore: [] },
                             x509: { bson: {}, authStore: [] },
                             plain: { bson: {}, authStore: [] },
                             gssapi: { bson: {}, authStore: [] },
                             sspi: { bson: {}, authStore: [] },
                             'scram-sha-1': { bson: {}, authStore: [], id: 0 } },
                          reconnectConnection: null,
                          authenticating: false,
                          loggingout: false,
                          nonAuthenticatedConnections: [],
                          authenticatingTimestamp: null,
                          numberOfConsecutiveTimeouts: 0,
                          connectionIndex: 1 },
                       disconnectHandler: 
                        { s: 
                           { storedOps: [],
                             storeOptions: { force: false, bufferMaxEntries: -1 },
                             topology: [Circular] },
                          length: [Getter] },
                       monitoring: true,
                       inTopology: false,
                       monitoringInterval: 5000,
                       topologyId: -1 },
                    ismaster: 
                     { ismaster: true,
                       maxBsonObjectSize: 16777216,
                       maxMessageSizeBytes: 48000000,
                       maxWriteBatchSize: 1000,
                       localTime: Fri Mar 24 2017 14:28:25 GMT+0100 (CET),
                       maxWireVersion: 4,
                       minWireVersion: 0,
                       ok: 1 },
                    lastIsMasterMS: 6,
                    monitoringProcessId: 
                     { _called: false,
                       _idleTimeout: 5000,
                       _idlePrev: 
                        Timer {
                          '0': [Function: listOnTimeout],
                          _idleNext: [Circular],
                          _idlePrev: [Circular],
                          msecs: 5000 },
                       _idleNext: 
                        Timer {
                          '0': [Function: listOnTimeout],
                          _idleNext: [Circular],
                          _idlePrev: [Circular],
                          msecs: 5000 },
                       _idleStart: 686,
                       _onTimeout: [Function],
                       _repeat: null },
                    initalConnect: false,
                    wireProtocolHandler: { legacyWireProtocol: {} },
                    _type: 'server',
                    clientInfo: 
                     { driver: { name: 'nodejs', version: '2.2.25' },
                       os: 
                        { type: 'Linux',
                          name: 'linux',
                          architecture: 'x64',
                          version: '3.16.0-4-amd64' },
                       platform: 'Node.js v4.7.2, LE, mongodb-core: 2.1.9' },
                    lastUpdateTime: 0,
                    lastWriteDate: 0,
                    staleness: 0 },
                 sCapabilities: null,
                 clonedOptions: 
                  { host: '127.0.0.1',
                    port: 27017,
                    disconnectHandler: 
                     { s: 
                        { storedOps: [],
                          storeOptions: { force: false, bufferMaxEntries: -1 },
                          topology: [Circular] },
                       length: [Getter] },
                    cursorFactory: 
                     { [Function]
                       super_: 
                        { [Function: Readable]
                          ReadableState: [Function: ReadableState],
                          super_: 
                           { [Function: Stream]
                             super_: 
                              { [Function: EventEmitter]
                                EventEmitter: [Circular],
                                usingDomains: false,
                                defaultMaxListeners: 10,
                                init: [Function],
                                listenerCount: [Function] },
                             Readable: [Circular],
                             Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                             Duplex: { [Function: Duplex] super_: [Circular] },
                             Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                             PassThrough: 
                              { [Function: PassThrough]
                                super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                             Stream: [Circular] },
                          _fromList: [Function: fromList] },
                       define: 
                        { name: 'Cursor',
                          object: [Circular],
                          stream: true,
                          instrumentations: 
                           { 'callback=true,promise=true': 
                              { methods: 
                                 [ 'hasNext',
                                   'next',
                                   'nextObject',
                                   'next',
                                   'toArray',
                                   'count',
                                   'close',
                                   'explain' ],
                                options: { callback: true, promise: true } },
                             'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                              { methods: 
                                 [ 'filter',
                                   'maxScan',
                                   'hint',
                                   'min',
                                   'max',
                                   'returnKey',
                                   'showRecordId',
                                   'snapshot',
                                   'setCursorOption',
                                   'addCursorFlag',
                                   'addQueryModifier',
                                   'comment',
                                   'maxAwaitTimeMS',
                                   'maxTimeMS',
                                   'maxTimeMs',
                                   'project',
                                   'sort',
                                   'batchSize',
                                   'collation',
                                   'limit',
                                   'skip',
                                   'setReadPreference',
                                   'map',
                                   'stream' ],
                                options: { callback: false, promise: false, returns: [ [Circular] ] } },
                             'callback=true,promise=false': 
                              { methods: [ 'each', 'forEach' ],
                                options: { callback: true, promise: false } },
                             'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                              { methods: [ 'isClosed' ],
                                options: 
                                 { callback: false,
                                   promise: false,
                                   returns: [ [Function: Boolean] ] } },
                             'callback=false,promise=false': 
                              { methods: [ 'destroy' ],
                                options: { callback: false, promise: false } } } },
                       INIT: 0,
                       OPEN: 1,
                       CLOSED: 2,
                       GET_MORE: 3,
                       super_Async: [Function] },
                    reconnect: true,
                    emitError: true,
                    size: 5,
                    socketOptions: {},
                    socketTimeout: 30000,
                    connectionTimeout: 30000,
                    clientInfo: 
                     { driver: { name: 'nodejs', version: '2.2.25' },
                       os: 
                        { type: 'Linux',
                          name: 'linux',
                          architecture: 'x64',
                          version: '3.16.0-4-amd64' },
                       platform: 'Node.js v4.7.2, LE' },
                    readPreference: 
                     { _type: 'ReadPreference',
                       mode: 'primary',
                       tags: undefined,
                       options: undefined },
                    promiseLibrary: [Function: Promise],
                    bson: {} },
                 reconnect: true,
                 emitError: true,
                 poolSize: 5,
                 storeOptions: { force: false, bufferMaxEntries: -1 },
                 store: 
                  { s: 
                     { storedOps: [],
                       storeOptions: { force: false, bufferMaxEntries: -1 },
                       topology: [Circular] },
                    length: [Getter] },
                 host: '127.0.0.1',
                 port: 27017,
                 options: 
                  { readPreference: 
                     { _type: 'ReadPreference',
                       mode: 'primary',
                       tags: undefined,
                       options: undefined },
                    promiseLibrary: [Function: Promise] } } },
           options: 
            { readPreference: 
               { _type: 'ReadPreference',
                 mode: 'primary',
                 tags: undefined,
                 options: undefined },
              promiseLibrary: [Function: Promise] },
           logger: { className: 'Db' },
           bson: {},
           authSource: undefined,
           readPreference: 
            { _type: 'ReadPreference',
              mode: 'primary',
              tags: undefined,
              options: undefined },
           bufferMaxEntries: -1,
           parentDb: null,
           pkFactory: undefined,
           nativeParser: undefined,
           promiseLibrary: [Function: Promise],
           noListener: false,
           readConcern: undefined },
        serverConfig: [Getter],
        bufferMaxEntries: [Getter],
        databaseName: [Getter] },
     topology: 
      EventEmitter {
        domain: null,
        _events: 
         { error: [Function],
           timeout: [Function],
           close: [Function],
           parseError: [Function],
           fullsetup: { [Function: g] listener: [Function] },
           all: { [Function: g] listener: [Function] },
           reconnect: [Function] },
        _eventsCount: 7,
        _maxListeners: undefined,
        clientInfo: 
         { driver: { name: 'nodejs', version: '2.2.25' },
           os: 
            { type: 'Linux',
              name: 'linux',
              architecture: 'x64',
              version: '3.16.0-4-amd64' },
           platform: 'Node.js v4.7.2, LE' },
        s: 
         { server: 
            EventEmitter {
              domain: null,
              _events: 
               { reconnect: [Function],
                 reconnectFailed: [Function],
                 timeout: [Function],
                 error: { [Function: g] listener: [Function] },
                 close: [Function],
                 destroy: [Function],
                 serverDescriptionChanged: [Function],
                 serverHeartbeatStarted: [Function],
                 serverHeartbeatSucceeded: [Function],
                 serverHeartbeatFailed: [Function],
                 serverOpening: [Function],
                 serverClosed: [Function],
                 topologyOpening: [Function],
                 topologyClosed: [Function],
                 topologyDescriptionChanged: [Function],
                 attemptReconnect: [Function],
                 monitoring: [Function] },
              _eventsCount: 17,
              _maxListeners: undefined,
              id: 0,
              s: 
               { options: 
                  { host: '127.0.0.1',
                    port: 27017,
                    disconnectHandler: 
                     { s: 
                        { storedOps: [],
                          storeOptions: { force: false, bufferMaxEntries: -1 },
                          topology: [Circular] },
                       length: [Getter] },
                    cursorFactory: 
                     { [Function]
                       super_: 
                        { [Function: Readable]
                          ReadableState: [Function: ReadableState],
                          super_: 
                           { [Function: Stream]
                             super_: 
                              { [Function: EventEmitter]
                                EventEmitter: [Circular],
                                usingDomains: false,
                                defaultMaxListeners: 10,
                                init: [Function],
                                listenerCount: [Function] },
                             Readable: [Circular],
                             Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                             Duplex: { [Function: Duplex] super_: [Circular] },
                             Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                             PassThrough: 
                              { [Function: PassThrough]
                                super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                             Stream: [Circular] },
                          _fromList: [Function: fromList] },
                       define: 
                        { name: 'Cursor',
                          object: [Circular],
                          stream: true,
                          instrumentations: 
                           { 'callback=true,promise=true': 
                              { methods: 
                                 [ 'hasNext',
                                   'next',
                                   'nextObject',
                                   'next',
                                   'toArray',
                                   'count',
                                   'close',
                                   'explain' ],
                                options: { callback: true, promise: true } },
                             'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                              { methods: 
                                 [ 'filter',
                                   'maxScan',
                                   'hint',
                                   'min',
                                   'max',
                                   'returnKey',
                                   'showRecordId',
                                   'snapshot',
                                   'setCursorOption',
                                   'addCursorFlag',
                                   'addQueryModifier',
                                   'comment',
                                   'maxAwaitTimeMS',
                                   'maxTimeMS',
                                   'maxTimeMs',
                                   'project',
                                   'sort',
                                   'batchSize',
                                   'collation',
                                   'limit',
                                   'skip',
                                   'setReadPreference',
                                   'map',
                                   'stream' ],
                                options: { callback: false, promise: false, returns: [ [Circular] ] } },
                             'callback=true,promise=false': 
                              { methods: [ 'each', 'forEach' ],
                                options: { callback: true, promise: false } },
                             'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                              { methods: [ 'isClosed' ],
                                options: 
                                 { callback: false,
                                   promise: false,
                                   returns: [ [Function: Boolean] ] } },
                             'callback=false,promise=false': 
                              { methods: [ 'destroy' ],
                                options: { callback: false, promise: false } } } },
                       INIT: 0,
                       OPEN: 1,
                       CLOSED: 2,
                       GET_MORE: 3,
                       super_Async: [Function] },
                    reconnect: true,
                    emitError: true,
                    size: 5,
                    socketOptions: {},
                    socketTimeout: 30000,
                    connectionTimeout: 30000,
                    clientInfo: 
                     { driver: { name: 'nodejs', version: '2.2.25' },
                       os: 
                        { type: 'Linux',
                          name: 'linux',
                          architecture: 'x64',
                          version: '3.16.0-4-amd64' },
                       platform: 'Node.js v4.7.2, LE' },
                    readPreference: 
                     { _type: 'ReadPreference',
                       mode: 'primary',
                       tags: undefined,
                       options: undefined },
                    promiseLibrary: [Function: Promise],
                    bson: {} },
                 logger: { className: 'Server' },
                 Cursor: 
                  { [Function]
                    super_: 
                     { [Function: Readable]
                       ReadableState: [Function: ReadableState],
                       super_: 
                        { [Function: Stream]
                          super_: 
                           { [Function: EventEmitter]
                             EventEmitter: [Circular],
                             usingDomains: false,
                             defaultMaxListeners: 10,
                             init: [Function],
                             listenerCount: [Function] },
                          Readable: [Circular],
                          Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                          Duplex: { [Function: Duplex] super_: [Circular] },
                          Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                          PassThrough: 
                           { [Function: PassThrough]
                             super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                          Stream: [Circular] },
                       _fromList: [Function: fromList] },
                    define: 
                     { name: 'Cursor',
                       object: [Circular],
                       stream: true,
                       instrumentations: 
                        { 'callback=true,promise=true': 
                           { methods: 
                              [ 'hasNext',
                                'next',
                                'nextObject',
                                'next',
                                'toArray',
                                'count',
                                'close',
                                'explain' ],
                             options: { callback: true, promise: true } },
                          'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                           { methods: 
                              [ 'filter',
                                'maxScan',
                                'hint',
                                'min',
                                'max',
                                'returnKey',
                                'showRecordId',
                                'snapshot',
                                'setCursorOption',
                                'addCursorFlag',
                                'addQueryModifier',
                                'comment',
                                'maxAwaitTimeMS',
                                'maxTimeMS',
                                'maxTimeMs',
                                'project',
                                'sort',
                                'batchSize',
                                'collation',
                                'limit',
                                'skip',
                                'setReadPreference',
                                'map',
                                'stream' ],
                             options: { callback: false, promise: false, returns: [ [Circular] ] } },
                          'callback=true,promise=false': 
                           { methods: [ 'each', 'forEach' ],
                             options: { callback: true, promise: false } },
                          'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                           { methods: [ 'isClosed' ],
                             options: 
                              { callback: false,
                                promise: false,
                                returns: [ [Function: Boolean] ] } },
                          'callback=false,promise=false': 
                           { methods: [ 'destroy' ],
                             options: { callback: false, promise: false } } } },
                    INIT: 0,
                    OPEN: 1,
                    CLOSED: 2,
                    GET_MORE: 3,
                    super_Async: [Function] },
                 bson: {},
                 pool: 
                  EventEmitter {
                    domain: null,
                    _events: 
                     { close: [Function],
                       error: [Function],
                       timeout: [Function],
                       parseError: [Function],
                       connect: [Function],
                       reconnect: [Function],
                       reconnectFailed: [Function] },
                    _eventsCount: 7,
                    _maxListeners: undefined,
                    options: 
                     { host: '127.0.0.1',
                       port: 27017,
                       size: 5,
                       connectionTimeout: 30000,
                       socketTimeout: 30000,
                       keepAlive: true,
                       keepAliveInitialDelay: 0,
                       noDelay: true,
                       ssl: false,
                       checkServerIdentity: true,
                       ca: null,
                       crl: null,
                       cert: null,
                       key: null,
                       passPhrase: null,
                       rejectUnauthorized: false,
                       promoteLongs: true,
                       promoteValues: true,
                       promoteBuffers: false,
                       reconnect: true,
                       reconnectInterval: 1000,
                       reconnectTries: 30,
                       domainsEnabled: false,
                       disconnectHandler: 
                        { s: 
                           { storedOps: [],
                             storeOptions: { force: false, bufferMaxEntries: -1 },
                             topology: [Circular] },
                          length: [Getter] },
                       cursorFactory: 
                        { [Function]
                          super_: 
                           { [Function: Readable]
                             ReadableState: [Function: ReadableState],
                             super_: 
                              { [Function: Stream]
                                super_: 
                                 { [Function: EventEmitter]
                                   EventEmitter: [Circular],
                                   usingDomains: false,
                                   defaultMaxListeners: 10,
                                   init: [Function],
                                   listenerCount: [Function] },
                                Readable: [Circular],
                                Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                                Duplex: { [Function: Duplex] super_: [Circular] },
                                Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                                PassThrough: 
                                 { [Function: PassThrough]
                                   super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                                Stream: [Circular] },
                             _fromList: [Function: fromList] },
                          define: 
                           { name: 'Cursor',
                             object: [Circular],
                             stream: true,
                             instrumentations: 
                              { 'callback=true,promise=true': 
                                 { methods: 
                                    [ 'hasNext',
                                      'next',
                                      'nextObject',
                                      'next',
                                      'toArray',
                                      'count',
                                      'close',
                                      'explain' ],
                                   options: { callback: true, promise: true } },
                                'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                                 { methods: 
                                    [ 'filter',
                                      'maxScan',
                                      'hint',
                                      'min',
                                      'max',
                                      'returnKey',
                                      'showRecordId',
                                      'snapshot',
                                      'setCursorOption',
                                      'addCursorFlag',
                                      'addQueryModifier',
                                      'comment',
                                      'maxAwaitTimeMS',
                                      'maxTimeMS',
                                      'maxTimeMs',
                                      'project',
                                      'sort',
                                      'batchSize',
                                      'collation',
                                      'limit',
                                      'skip',
                                      'setReadPreference',
                                      'map',
                                      'stream' ],
                                   options: { callback: false, promise: false, returns: [ [Circular] ] } },
                                'callback=true,promise=false': 
                                 { methods: [ 'each', 'forEach' ],
                                   options: { callback: true, promise: false } },
                                'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                                 { methods: [ 'isClosed' ],
                                   options: 
                                    { callback: false,
                                      promise: false,
                                      returns: [ [Function: Boolean] ] } },
                                'callback=false,promise=false': 
                                 { methods: [ 'destroy' ],
                                   options: { callback: false, promise: false } } } },
                          INIT: 0,
                          OPEN: 1,
                          CLOSED: 2,
                          GET_MORE: 3,
                          super_Async: [Function] },
                       emitError: true,
                       socketOptions: {},
                       clientInfo: 
                        { driver: { name: 'nodejs', version: '2.2.25' },
                          os: 
                           { type: 'Linux',
                             name: 'linux',
                             architecture: 'x64',
                             version: '3.16.0-4-amd64' },
                          platform: 'Node.js v4.7.2, LE' },
                       readPreference: 
                        { _type: 'ReadPreference',
                          mode: 'primary',
                          tags: undefined,
                          options: undefined },
                       promiseLibrary: [Function: Promise],
                       bson: {} },
                    id: 0,
                    retriesLeft: 30,
                    reconnectId: null,
                    logger: { className: 'Pool' },
                    state: 'connected',
                    availableConnections: 
                     [ EventEmitter {
                         domain: null,
                         _events: 
                          { error: { [Function: g] listener: [Function] },
                            close: { [Function: g] listener: [Function] },
                            timeout: { [Function: g] listener: [Function] },
                            parseError: { [Function: g] listener: [Function] } },
                         _eventsCount: 4,
                         _maxListeners: undefined,
                         options: 
                          { host: '127.0.0.1',
                            port: 27017,
                            size: 5,
                            connectionTimeout: 30000,
                            socketTimeout: 30000,
                            keepAlive: true,
                            keepAliveInitialDelay: 0,
                            noDelay: true,
                            ssl: false,
                            checkServerIdentity: true,
                            ca: null,
                            crl: null,
                            cert: null,
                            key: null,
                            passPhrase: null,
                            rejectUnauthorized: false,
                            promoteLongs: true,
                            promoteValues: true,
                            promoteBuffers: false,
                            reconnect: true,
                            reconnectInterval: 1000,
                            reconnectTries: 30,
                            domainsEnabled: false,
                            disconnectHandler: 
                             { s: 
                                { storedOps: [],
                                  storeOptions: { force: false, bufferMaxEntries: -1 },
                                  topology: [Circular] },
                               length: [Getter] },
                            cursorFactory: 
                             { [Function]
                               super_: 
                                { [Function: Readable]
                                  ReadableState: [Function: ReadableState],
                                  super_: 
                                   { [Function: Stream]
                                     super_: 
                                      { [Function: EventEmitter]
                                        EventEmitter: [Circular],
                                        usingDomains: false,
                                        defaultMaxListeners: 10,
                                        init: [Function],
                                        listenerCount: [Function] },
                                     Readable: [Circular],
                                     Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                                     Duplex: { [Function: Duplex] super_: [Circular] },
                                     Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                                     PassThrough: 
                                      { [Function: PassThrough]
                                        super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                                     Stream: [Circular] },
                                  _fromList: [Function: fromList] },
                               define: 
                                { name: 'Cursor',
                                  object: [Circular],
                                  stream: true,
                                  instrumentations: 
                                   { 'callback=true,promise=true': 
                                      { methods: 
                                         [ 'hasNext',
                                           'next',
                                           'nextObject',
                                           'next',
                                           'toArray',
                                           'count',
                                           'close',
                                           'explain' ],
                                        options: { callback: true, promise: true } },
                                     'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                                      { methods: 
                                         [ 'filter',
                                           'maxScan',
                                           'hint',
                                           'min',
                                           'max',
                                           'returnKey',
                                           'showRecordId',
                                           'snapshot',
                                           'setCursorOption',
                                           'addCursorFlag',
                                           'addQueryModifier',
                                           'comment',
                                           'maxAwaitTimeMS',
                                           'maxTimeMS',
                                           'maxTimeMs',
                                           'project',
                                           'sort',
                                           'batchSize',
                                           'collation',
                                           'limit',
                                           'skip',
                                           'setReadPreference',
                                           'map',
                                           'stream' ],
                                        options: { callback: false, promise: false, returns: [ [Circular] ] } },
                                     'callback=true,promise=false': 
                                      { methods: [ 'each', 'forEach' ],
                                        options: { callback: true, promise: false } },
                                     'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                                      { methods: [ 'isClosed' ],
                                        options: 
                                         { callback: false,
                                           promise: false,
                                           returns: [ [Function: Boolean] ] } },
                                     'callback=false,promise=false': 
                                      { methods: [ 'destroy' ],
                                        options: { callback: false, promise: false } } } },
                               INIT: 0,
                               OPEN: 1,
                               CLOSED: 2,
                               GET_MORE: 3,
                               super_Async: [Function] },
                            emitError: true,
                            socketOptions: {},
                            clientInfo: 
                             { driver: { name: 'nodejs', version: '2.2.25' },
                               os: 
                                { type: 'Linux',
                                  name: 'linux',
                                  architecture: 'x64',
                                  version: '3.16.0-4-amd64' },
                               platform: 'Node.js v4.7.2, LE' },
                            readPreference: 
                             { _type: 'ReadPreference',
                               mode: 'primary',
                               tags: undefined,
                               options: undefined },
                            promiseLibrary: [Function: Promise],
                            bson: {} },
                         id: 0,
                         logger: { className: 'Connection' },
                         bson: {},
                         tag: undefined,
                         messageHandler: [Function],
                         maxBsonMessageSize: 67108864,
                         port: 27017,
                         host: '127.0.0.1',
                         keepAlive: true,
                         keepAliveInitialDelay: 0,
                         noDelay: true,
                         connectionTimeout: 30000,
                         socketTimeout: 30000,
                         destroyed: false,
                         domainSocket: false,
                         singleBufferSerializtion: true,
                         serializationFunction: 'toBinUnified',
                         ca: null,
                         crl: null,
                         cert: null,
                         key: null,
                         passphrase: null,
                         ssl: false,
                         rejectUnauthorized: false,
                         checkServerIdentity: true,
                         responseOptions: 
                          { promoteLongs: true,
                            promoteValues: true,
                            promoteBuffers: false },
                         flushing: false,
                         queue: [],
                         connection: 
                          Socket {
                            _connecting: false,
                            _hadError: false,
                            _handle: 
                             TCP {
                               bytesRead: 194,
                               _externalStream: {},
                               fd: 12,
                               reading: true,
                               owner: [Circular],
                               onread: [Function: onread],
                               onconnection: null,
                               writeQueueSize: 0 },
                            _parent: null,
                            _host: null,
                            _readableState: 
                             ReadableState {
                               objectMode: false,
                               highWaterMark: 16384,
                               buffer: [],
                               length: 0,
                               pipes: null,
                               pipesCount: 0,
                               flowing: true,
                               ended: false,
                               endEmitted: false,
                               reading: true,
                               sync: false,
                               needReadable: true,
                               emittedReadable: false,
                               readableListening: false,
                               resumeScheduled: false,
                               defaultEncoding: 'utf8',
                               ranOut: false,
                               awaitDrain: 0,
                               readingMore: false,
                               decoder: null,
                               encoding: null },
                            readable: true,
                            domain: null,
                            _events: 
                             { end: { [Function: g] listener: [Function: onend] },
                               finish: [Function: onSocketFinish],
                               _socketEnd: [Function: onSocketEnd],
                               connect: [ [Function] ],
                               error: { [Function: g] listener: [Function] },
                               timeout: { [Function: g] listener: [Function] },
                               close: { [Function: g] listener: [Function] },
                               data: [Function] },
                            _eventsCount: 8,
                            _maxListeners: undefined,
                            _writableState: 
                             WritableState {
                               objectMode: false,
                               highWaterMark: 16384,
                               needDrain: false,
                               ending: false,
                               ended: false,
                               finished: false,
                               decodeStrings: false,
                               defaultEncoding: 'utf8',
                               length: 0,
                               writing: false,
                               corked: 0,
                               sync: false,
                               bufferProcessing: false,
                               onwrite: [Function],
                               writecb: null,
                               writelen: 0,
                               bufferedRequest: null,
                               lastBufferedRequest: null,
                               pendingcb: 0,
                               prefinished: false,
                               errorEmitted: false,
                               bufferedRequestCount: 0,
                               corkedRequestsFree: CorkedRequest { next: null, entry: null, finish: [Function] } },
                            writable: true,
                            allowHalfOpen: false,
                            destroyed: false,
                            _bytesDispatched: 263,
                            _sockname: null,
                            _pendingData: null,
                            _pendingEncoding: '',
                            server: null,
                            _server: null,
                            _idleTimeout: 30000,
                            _idleNext: { _idleNext: [Circular], _idlePrev: [Circular] },
                            _idlePrev: { _idleNext: [Circular], _idlePrev: [Circular] },
                            _idleStart: 684,
                            read: [Function],
                            _consuming: true },
                         writeStream: null,
                         hashedName: '1af0a80ead1d9e3c1a02ad090ffe77ff1334aae9',
                         workItems: [],
                         buffer: null,
                         sizeOfMessage: 0,
                         bytesRead: 0,
                         stubBuffer: null } ],
                    inUseConnections: [],
                    connectingConnections: [],
                    executing: false,
                    queue: [],
                    authProviders: 
                     { mongocr: { bson: {}, authStore: [] },
                       x509: { bson: {}, authStore: [] },
                       plain: { bson: {}, authStore: [] },
                       gssapi: { bson: {}, authStore: [] },
                       sspi: { bson: {}, authStore: [] },
                       'scram-sha-1': { bson: {}, authStore: [], id: 0 } },
                    reconnectConnection: null,
                    authenticating: false,
                    loggingout: false,
                    nonAuthenticatedConnections: [],
                    authenticatingTimestamp: null,
                    numberOfConsecutiveTimeouts: 0,
                    connectionIndex: 1 },
                 disconnectHandler: 
                  { s: 
                     { storedOps: [],
                       storeOptions: { force: false, bufferMaxEntries: -1 },
                       topology: [Circular] },
                    length: [Getter] },
                 monitoring: true,
                 inTopology: false,
                 monitoringInterval: 5000,
                 topologyId: -1 },
              ismaster: 
               { ismaster: true,
                 maxBsonObjectSize: 16777216,
                 maxMessageSizeBytes: 48000000,
                 maxWriteBatchSize: 1000,
                 localTime: Fri Mar 24 2017 14:28:25 GMT+0100 (CET),
                 maxWireVersion: 4,
                 minWireVersion: 0,
                 ok: 1 },
              lastIsMasterMS: 6,
              monitoringProcessId: 
               { _called: false,
                 _idleTimeout: 5000,
                 _idlePrev: 
                  Timer {
                    '0': [Function: listOnTimeout],
                    _idleNext: [Circular],
                    _idlePrev: [Circular],
                    msecs: 5000 },
                 _idleNext: 
                  Timer {
                    '0': [Function: listOnTimeout],
                    _idleNext: [Circular],
                    _idlePrev: [Circular],
                    msecs: 5000 },
                 _idleStart: 686,
                 _onTimeout: [Function],
                 _repeat: null },
              initalConnect: false,
              wireProtocolHandler: { legacyWireProtocol: {} },
              _type: 'server',
              clientInfo: 
               { driver: { name: 'nodejs', version: '2.2.25' },
                 os: 
                  { type: 'Linux',
                    name: 'linux',
                    architecture: 'x64',
                    version: '3.16.0-4-amd64' },
                 platform: 'Node.js v4.7.2, LE, mongodb-core: 2.1.9' },
              lastUpdateTime: 0,
              lastWriteDate: 0,
              staleness: 0 },
           sCapabilities: null,
           clonedOptions: 
            { host: '127.0.0.1',
              port: 27017,
              disconnectHandler: 
               { s: 
                  { storedOps: [],
                    storeOptions: { force: false, bufferMaxEntries: -1 },
                    topology: [Circular] },
                 length: [Getter] },
              cursorFactory: 
               { [Function]
                 super_: 
                  { [Function: Readable]
                    ReadableState: [Function: ReadableState],
                    super_: 
                     { [Function: Stream]
                       super_: 
                        { [Function: EventEmitter]
                          EventEmitter: [Circular],
                          usingDomains: false,
                          defaultMaxListeners: 10,
                          init: [Function],
                          listenerCount: [Function] },
                       Readable: [Circular],
                       Writable: { [Function: Writable] WritableState: [Function: WritableState], super_: [Circular] },
                       Duplex: { [Function: Duplex] super_: [Circular] },
                       Transform: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } },
                       PassThrough: 
                        { [Function: PassThrough]
                          super_: { [Function: Transform] super_: { [Function: Duplex] super_: [Circular] } } },
                       Stream: [Circular] },
                    _fromList: [Function: fromList] },
                 define: 
                  { name: 'Cursor',
                    object: [Circular],
                    stream: true,
                    instrumentations: 
                     { 'callback=true,promise=true': 
                        { methods: 
                           [ 'hasNext',
                             'next',
                             'nextObject',
                             'next',
                             'toArray',
                             'count',
                             'close',
                             'explain' ],
                          options: { callback: true, promise: true } },
                       'callback=false,promise=false,returns=function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {};\n\n  // Tailable cursor options\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries;\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == \'function\' ?\n      global.Promise : require(\'es6-promise\').Promise;\n  }\n\n  // Set up\n  Readable.call(this, {objectMode: true});\n\n  // Internal cursor state\n  this.s = {\n    // Tailable cursor options\n      numberOfRetries: numberOfRetries\n    , tailableRetryInterval: tailableRetryInterval\n    , currentNumberOfRetries: currentNumberOfRetries\n    // State\n    , state: state\n    // Stream options\n    , streamOptions: streamOptions\n    // BSON\n    , bson: bson\n    // Namespace\n    , ns: ns\n    // Command\n    , cmd: cmd\n    // Options\n    , options: options\n    // Topology\n    , topology: topology\n    // Topology options\n    , topologyOptions: topologyOptions\n    // Promise library\n    , promiseLibrary: promiseLibrary\n    // Current doc\n    , currentDoc: null\n  }\n\n  // Translate correctly\n  if(self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag(\'noCursorTimeout\', true);\n  }\n\n  // Set the sort value\n  this.sortValue = self.s.cmd.sort;\n\n  // Get the batchSize\n  var batchSize = cmd.cursor && cmd.cursor.batchSize\n    ? cmd.cursor && cmd.cursor.batchSize\n    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);\n\n  // Set the batchSize\n  this.setCursorBatchSize(batchSize);\n}': 
                        { methods: 
                           [ 'filter',
                             'maxScan',
                             'hint',
                             'min',
                             'max',
                             'returnKey',
                             'showRecordId',
                             'snapshot',
                             'setCursorOption',
                             'addCursorFlag',
                             'addQueryModifier',
                             'comment',
                             'maxAwaitTimeMS',
                             'maxTimeMS',
                             'maxTimeMs',
                             'project',
                             'sort',
                             'batchSize',
                             'collation',
                             'limit',
                             'skip',
                             'setReadPreference',
                             'map',
                             'stream' ],
                          options: { callback: false, promise: false, returns: [ [Circular] ] } },
                       'callback=true,promise=false': 
                        { methods: [ 'each', 'forEach' ],
                          options: { callback: true, promise: false } },
                       'callback=false,promise=false,returns=function Boolean() { [native code] }': 
                        { methods: [ 'isClosed' ],
                          options: 
                           { callback: false,
                             promise: false,
                             returns: [ [Function: Boolean] ] } },
                       'callback=false,promise=false': 
                        { methods: [ 'destroy' ],
                          options: { callback: false, promise: false } } } },
                 INIT: 0,
                 OPEN: 1,
                 CLOSED: 2,
                 GET_MORE: 3,
                 super_Async: [Function] },
              reconnect: true,
              emitError: true,
              size: 5,
              socketOptions: {},
              socketTimeout: 30000,
              connectionTimeout: 30000,
              clientInfo: 
               { driver: { name: 'nodejs', version: '2.2.25' },
                 os: 
                  { type: 'Linux',
                    name: 'linux',
                    architecture: 'x64',
                    version: '3.16.0-4-amd64' },
                 platform: 'Node.js v4.7.2, LE' },
              readPreference: 
               { _type: 'ReadPreference',
                 mode: 'primary',
                 tags: undefined,
                 options: undefined },
              promiseLibrary: [Function: Promise],
              bson: {} },
           reconnect: true,
           emitError: true,
           poolSize: 5,
           storeOptions: { force: false, bufferMaxEntries: -1 },
           store: 
            { s: 
               { storedOps: [],
                 storeOptions: { force: false, bufferMaxEntries: -1 },
                 topology: [Circular] },
              length: [Getter] },
           host: '127.0.0.1',
           port: 27017,
           options: 
            { readPreference: 
               { _type: 'ReadPreference',
                 mode: 'primary',
                 tags: undefined,
                 options: undefined },
              promiseLibrary: [Function: Promise] } } },
     dbName: 'admin',
     options: { promiseLibrary: [Function: Promise], readConcern: undefined },
     namespace: 'admin.users',
     readPreference: 
      { _type: 'ReadPreference',
        mode: 'primary',
        tags: undefined,
        options: undefined },
     slaveOk: true,
     serializeFunctions: undefined,
     raw: undefined,
     promoteLongs: undefined,
     promoteValues: undefined,
     promoteBuffers: undefined,
     internalHint: null,
     collectionHint: null,
     name: 'users',
     promiseLibrary: [Function: Promise],
     readConcern: undefined } }
API Seneca Listening on: 5002
[]
{"kind":"notice","notice":"hello seneca 1x8hig3u75qd/1490362105906/10556/3.3.0/-","level":"info","when":1490362106033}
